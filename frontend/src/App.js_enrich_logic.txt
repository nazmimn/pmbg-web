  const enrichWithBGG = async (items) => {
    const updatedItems = [...items];
    for (let i = 0; i < updatedItems.length; i++) {
        const item = updatedItems[i];
        if (!item.title) continue;

        try {
            if (i > 0) await new Promise(r => setTimeout(r, 500));
            const res = await api.get(`/bgg/search?q=${encodeURIComponent(item.title)}`);
            const results = res.data;
            if (!results || results.length === 0) continue;

            const exactMatch = results.find(r => r.title.toLowerCase() === item.title.toLowerCase());
            const match = exactMatch || results[0];

            if (match) {
                 updatedItems[i] = { ...item };
                 // Overwrite or fill image
                 if (match.image) {
                     updatedItems[i].image = match.image;
                     updatedItems[i].images = [match.image];
                     updatedItems[i].bggId = match.id;
                 }
                 // Fill description if missing or short? BGG desc is usually good
                 if (match.description) {
                     updatedItems[i].description = match.description.replace(/<[^>]*>/g, ' ').slice(0, 1000) + "...";
                 }
            }
        } catch (e) { console.error(e); }
    }
    return updatedItems;
  };

  const processScanFile = (file) => {
    if (!file) return;
    const reader = new FileReader();
    reader.onloadend = async () => {
      const base64 = reader.result;
      setIsAnalyzing(true);
      setErrorMsg('');
      try {
        const res = await api.post('/ai/scan-image', { image: base64 });
        const items = Array.isArray(res.data) ? res.data : [res.data];
        
        const compressed = await resizeImage(file); 
        const itemsWithImg = items.map(i => ({ 
          ...i, 
          images: [compressed], 
          image: compressed, 
          type: formData.type || 'WTS',
          openForTrade: false 
        }));
        
        // Auto-search BGG covers immediately
        const enrichedItems = await enrichWithBGG(itemsWithImg);
        
        setDetectedItems(enrichedItems);
        setStep('review');
      } catch (err) {
        console.error(err);
        setErrorMsg("Failed to identify boardgames. Try again.");
      } finally {
        setIsAnalyzing(false);
      }
    };
    reader.readAsDataURL(file);
  };

  const handleTextAnalysis = async () => {
    if (!inputText) return;
    setIsAnalyzing(true);
    setErrorMsg('');
    try {
      const res = await api.post('/ai/parse-text', { text: inputText });
      const items = res.data;
      const formatted = (Array.isArray(items) ? items : [items]).map(i => ({...i, type: formData.type || 'WTS', images: [], image: '', openForTrade: false}));
      
      // Auto-search BGG covers immediately
      const enrichedItems = await enrichWithBGG(formatted);

      setDetectedItems(enrichedItems);
      setStep('review');
    } catch (err) {
      console.error(err);
      setErrorMsg("Failed to parse text.");
    } finally {
      setIsAnalyzing(false);
    }
  };

  const handleQuickList = async () => {
     if (!inputText) return;
     setIsAnalyzing(true);
     const titles = inputText.split('\n').filter(t => t.trim().length > 0);
     const items = titles.map(t => ({
        type: 'WTB',
        title: t.trim(),
        price: '',
        condition: 8.0,
        images: [],
        image: '',
        description: '',
        openForTrade: false
     }));
     
     // Auto-search BGG covers for quick list too
     const enrichedItems = await enrichWithBGG(items);
     
     setDetectedItems(enrichedItems);
     setStep('review');
     setIsAnalyzing(false);
  }
